(function (factory) {
    typeof define === 'function' && define.amd ? define(factory) :
    factory();
}((function () { 'use strict';

    function invariant(condition, message, Err) {
        if (Err === void 0) { Err = Error; }
        if (!condition) {
            throw new Err(message);
        }
    }

    /**
     * https://tc39.es/ecma262/#sec-toobject
     * @param arg
     */
    function toObject(arg) {
        if (arg == null) {
            throw new TypeError('undefined/null cannot be converted to object');
        }
        return Object(arg);
    }
    /**
     * https://tc39.es/ecma402/#sec-getoption
     * @param opts
     * @param prop
     * @param type
     * @param values
     * @param fallback
     */
    function getOption(opts, prop, type, values, fallback) {
        // const descriptor = Object.getOwnPropertyDescriptor(opts, prop);
        var value = opts[prop];
        if (value !== undefined) {
            if (type !== 'boolean' && type !== 'string') {
                throw new TypeError('invalid type');
            }
            if (type === 'boolean') {
                value = Boolean(value);
            }
            if (type === 'string') {
                value = String(value);
            }
            if (values !== undefined && !values.filter(function (val) { return val == value; }).length) {
                throw new RangeError(value + " in not within " + values);
            }
            return value;
        }
        return fallback;
    }
    /**
     * https://tc39.es/ecma402/#sec-defaultnumberoption
     * @param val
     * @param min
     * @param max
     * @param fallback
     */
    function defaultNumberOption(val, min, max, fallback) {
        if (val !== undefined) {
            val = Number(val);
            if (isNaN(val) || val < min || val > max) {
                throw new RangeError(val + " is outside of range [" + min + ", " + max + "]");
            }
            return Math.floor(val);
        }
        return fallback;
    }
    /**
     * https://tc39.es/ecma402/#sec-getnumberoption
     * @param options
     * @param property
     * @param min
     * @param max
     * @param fallback
     */
    function getNumberOption(options, property, minimum, maximum, fallback) {
        var val = options[property];
        return defaultNumberOption(val, minimum, maximum, fallback);
    }
    function setInternalSlot(map, pl, field, value) {
        var _a;
        setMultiInternalSlots(map, pl, (_a = {}, _a[field] = value, _a));
    }
    function setMultiInternalSlots(map, pl, props) {
        if (!map.get(pl)) {
            map.set(pl, Object.create(null));
        }
        var slots = map.get(pl);
        Object.assign(slots, props);
    }
    function getInternalSlot(map, pl, field) {
        return getMultiInternalSlots(map, pl, field)[field];
    }
    function getMultiInternalSlots(map, pl) {
        var fields = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            fields[_i - 2] = arguments[_i];
        }
        var slots = map.get(pl);
        if (!slots) {
            throw new TypeError(pl + " InternalSlot has not been initialized");
        }
        return fields.reduce(function (all, f) {
            all[f] = slots[f];
            return all;
        }, {});
    }
    /**
     * https://tc39.es/ecma402/#sec-setnfdigitoptions
     * https://tc39.es/proposal-unified-intl-numberformat/section11/numberformat_diff_out.html#sec-setnfdigitoptions
     * @param pl
     * @param opts
     * @param mnfdDefault
     * @param mxfdDefault
     */
    function setNumberFormatDigitOptions(internalSlotMap, pl, opts, mnfdDefault, mxfdDefault, notation) {
        var mnid = getNumberOption(opts, 'minimumIntegerDigits', 1, 21, 1);
        var mnfd = opts.minimumFractionDigits;
        var mxfd = opts.maximumFractionDigits;
        var mnsd = opts.minimumSignificantDigits;
        var mxsd = opts.maximumSignificantDigits;
        setInternalSlot(internalSlotMap, pl, 'minimumIntegerDigits', mnid);
        if (mnsd !== undefined || mxsd !== undefined) {
            setInternalSlot(internalSlotMap, pl, 'roundingType', 'significantDigits');
            mnsd = defaultNumberOption(mnsd, 1, 21, 1);
            mxsd = defaultNumberOption(mxsd, mnsd, 21, 21);
            setInternalSlot(internalSlotMap, pl, 'minimumSignificantDigits', mnsd);
            setInternalSlot(internalSlotMap, pl, 'maximumSignificantDigits', mxsd);
        }
        else if (mnfd !== undefined || mxfd !== undefined) {
            setInternalSlot(internalSlotMap, pl, 'roundingType', 'fractionDigits');
            mnfd = defaultNumberOption(mnfd, 0, 20, mnfdDefault);
            var mxfdActualDefault = Math.max(mnfd, mxfdDefault);
            mxfd = defaultNumberOption(mxfd, mnfd, 20, mxfdActualDefault);
            setInternalSlot(internalSlotMap, pl, 'minimumFractionDigits', mnfd);
            setInternalSlot(internalSlotMap, pl, 'maximumFractionDigits', mxfd);
        }
        else if (notation === 'compact') {
            setInternalSlot(internalSlotMap, pl, 'roundingType', 'compactRounding');
        }
        else {
            setInternalSlot(internalSlotMap, pl, 'roundingType', 'fractionDigits');
            setInternalSlot(internalSlotMap, pl, 'minimumFractionDigits', mnfdDefault);
            setInternalSlot(internalSlotMap, pl, 'maximumFractionDigits', mxfdDefault);
        }
    }
    function objectIs(x, y) {
        if (Object.is) {
            return Object.is(x, y);
        }
        // SameValue algorithm
        if (x === y) {
            // Steps 1-5, 7-10
            // Steps 6.b-6.e: +0 != -0
            return x !== 0 || 1 / x === 1 / y;
        }
        // Step 6.a: NaN == NaN
        return x !== x && y !== y;
    }

    /**
     * IE11-safe version of getCanonicalLocales since it's ES2016
     * @param locales locales
     */
    function getCanonicalLocales(locales) {
        // IE11
        var getCanonicalLocales = Intl.getCanonicalLocales;
        if (typeof getCanonicalLocales === 'function') {
            return getCanonicalLocales(locales);
        }
        return Intl.NumberFormat.supportedLocalesOf(locales || '');
    }

    var __extends = (undefined && undefined.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign = (undefined && undefined.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function createResolveLocale(getDefaultLocale) {
        var lookupMatcher = createLookupMatcher(getDefaultLocale);
        var bestFitMatcher = createBestFitMatcher(getDefaultLocale);
        /**
         * https://tc39.es/ecma402/#sec-resolvelocale
         */
        return function resolveLocale(availableLocales, requestedLocales, options, relevantExtensionKeys, localeData) {
            var matcher = options.localeMatcher;
            var r;
            if (matcher === 'lookup') {
                r = lookupMatcher(availableLocales, requestedLocales);
            }
            else {
                r = bestFitMatcher(availableLocales, requestedLocales);
            }
            var foundLocale = r.locale;
            var result = { locale: '', dataLocale: foundLocale };
            var supportedExtension = '-u';
            for (var _i = 0, relevantExtensionKeys_1 = relevantExtensionKeys; _i < relevantExtensionKeys_1.length; _i++) {
                var key = relevantExtensionKeys_1[_i];
                var foundLocaleData = localeData[foundLocale];
                invariant(typeof foundLocaleData === 'object' && foundLocaleData !== null, "locale data " + key + " must be an object");
                var keyLocaleData = foundLocaleData[key];
                invariant(Array.isArray(keyLocaleData), "keyLocaleData for " + key + " must be an array");
                var value = keyLocaleData[0];
                invariant(typeof value === 'string' || value === null, 'value must be string or null');
                var supportedExtensionAddition = '';
                if (r.extension) {
                    var requestedValue = unicodeExtensionValue(r.extension, key);
                    if (requestedValue !== undefined) {
                        if (requestedValue !== '') {
                            if (~keyLocaleData.indexOf(requestedValue)) {
                                value = requestedValue;
                                supportedExtensionAddition = "-" + key + "-" + value;
                            }
                        }
                        else if (~requestedValue.indexOf('true')) {
                            value = 'true';
                            supportedExtensionAddition = "-" + key;
                        }
                    }
                }
                if (key in options) {
                    var optionsValue = options[key];
                    invariant(typeof optionsValue === 'string' ||
                        typeof optionsValue === 'undefined' ||
                        optionsValue === null, 'optionsValue must be String, Undefined or Null');
                    if (~keyLocaleData.indexOf(optionsValue)) {
                        if (optionsValue !== value) {
                            value = optionsValue;
                            supportedExtensionAddition = '';
                        }
                    }
                }
                result[key] = value;
                supportedExtension += supportedExtensionAddition;
            }
            if (supportedExtension.length > 2) {
                var privateIndex = foundLocale.indexOf('-x-');
                if (privateIndex === -1) {
                    foundLocale = foundLocale + supportedExtension;
                }
                else {
                    var preExtension = foundLocale.slice(0, privateIndex);
                    var postExtension = foundLocale.slice(privateIndex, foundLocale.length);
                    foundLocale = preExtension + supportedExtension + postExtension;
                }
                foundLocale = getCanonicalLocales(foundLocale)[0];
            }
            result.locale = foundLocale;
            return result;
        };
    }
    /**
     * https://tc39.es/ecma402/#sec-unicodeextensionvalue
     * @param extension
     * @param key
     */
    function unicodeExtensionValue(extension, key) {
        invariant(key.length === 2, 'key must have 2 elements');
        var size = extension.length;
        var searchValue = "-" + key + "-";
        var pos = extension.indexOf(searchValue);
        if (pos !== -1) {
            var start = pos + 4;
            var end = start;
            var k = start;
            var done = false;
            while (!done) {
                var e = extension.indexOf('-', k);
                var len = void 0;
                if (e === -1) {
                    len = size - k;
                }
                else {
                    len = e - k;
                }
                if (len === 2) {
                    done = true;
                }
                else if (e === -1) {
                    end = size;
                    done = true;
                }
                else {
                    end = e;
                    k = e + 1;
                }
            }
            return extension.slice(start, end);
        }
        searchValue = "-" + key;
        pos = extension.indexOf(searchValue);
        if (pos !== -1 && pos + 3 === size) {
            return '';
        }
        return undefined;
    }
    var UNICODE_EXTENSION_SEQUENCE_REGEX = /-u(?:-[0-9a-z]{2,8})+/gi;
    /**
     * https://tc39.es/ecma402/#sec-bestavailablelocale
     * @param availableLocales
     * @param locale
     */
    function bestAvailableLocale(availableLocales, locale) {
        var candidate = locale;
        while (true) {
            if (~availableLocales.indexOf(candidate)) {
                return candidate;
            }
            var pos = candidate.lastIndexOf('-');
            if (!~pos) {
                return undefined;
            }
            if (pos >= 2 && candidate[pos - 2] === '-') {
                pos -= 2;
            }
            candidate = candidate.slice(0, pos);
        }
    }
    function createLookupMatcher(getDefaultLocale) {
        /**
         * https://tc39.es/ecma402/#sec-lookupmatcher
         */
        return function lookupMatcher(availableLocales, requestedLocales) {
            var result = { locale: '' };
            for (var _i = 0, requestedLocales_1 = requestedLocales; _i < requestedLocales_1.length; _i++) {
                var locale = requestedLocales_1[_i];
                var noExtensionLocale = locale.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, '');
                var availableLocale = bestAvailableLocale(availableLocales, noExtensionLocale);
                if (availableLocale) {
                    result.locale = availableLocale;
                    if (locale !== noExtensionLocale) {
                        result.extension = locale.slice(noExtensionLocale.length + 1, locale.length);
                    }
                    return result;
                }
            }
            result.locale = getDefaultLocale();
            return result;
        };
    }
    function createBestFitMatcher(getDefaultLocale) {
        return function bestFitMatcher(availableLocales, requestedLocales) {
            var result = { locale: '' };
            for (var _i = 0, requestedLocales_2 = requestedLocales; _i < requestedLocales_2.length; _i++) {
                var locale = requestedLocales_2[_i];
                var noExtensionLocale = locale.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, '');
                var availableLocale = bestAvailableLocale(availableLocales, noExtensionLocale);
                if (availableLocale) {
                    result.locale = availableLocale;
                    if (locale !== noExtensionLocale) {
                        result.extension = locale.slice(noExtensionLocale.length + 1, locale.length);
                    }
                    return result;
                }
            }
            result.locale = getDefaultLocale();
            return result;
        };
    }
    function getLocaleHierarchy(locale, aliases, parentLocales) {
        var results = [locale];
        if (aliases[locale]) {
            locale = aliases[locale];
            results.push(locale);
        }
        var parentLocale = parentLocales[locale];
        if (parentLocale) {
            results.push(parentLocale);
        }
        var localeParts = locale.split('-');
        for (var i = localeParts.length; i > 1; i--) {
            results.push(localeParts.slice(0, i - 1).join('-'));
        }
        return results;
    }
    function lookupSupportedLocales(availableLocales, requestedLocales) {
        var subset = [];
        for (var _i = 0, requestedLocales_3 = requestedLocales; _i < requestedLocales_3.length; _i++) {
            var locale = requestedLocales_3[_i];
            var noExtensionLocale = locale.replace(UNICODE_EXTENSION_SEQUENCE_REGEX, '');
            var availableLocale = bestAvailableLocale(availableLocales, noExtensionLocale);
            if (availableLocale) {
                subset.push(availableLocale);
            }
        }
        return subset;
    }
    function supportedLocales(availableLocales, requestedLocales, options) {
        var matcher = 'best fit';
        if (options !== undefined) {
            options = toObject(options);
            matcher = getOption(options, 'localeMatcher', 'string', ['lookup', 'best fit'], 'best fit');
        }
        if (matcher === 'best fit') {
            return lookupSupportedLocales(availableLocales, requestedLocales);
        }
        return lookupSupportedLocales(availableLocales, requestedLocales);
    }
    var MissingLocaleDataError = /** @class */ (function (_super) {
        __extends(MissingLocaleDataError, _super);
        function MissingLocaleDataError() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 'MISSING_LOCALE_DATA';
            return _this;
        }
        return MissingLocaleDataError;
    }(Error));
    function unpackData(locale, localeData, 
    /** By default shallow merge the dictionaries. */
    reducer) {
        if (reducer === void 0) { reducer = function (all, d) { return (__assign(__assign({}, all), d)); }; }
        var localeHierarchy = getLocaleHierarchy(locale, localeData.aliases, localeData.parentLocales);
        var dataToMerge = localeHierarchy
            .map(function (l) { return localeData.data[l]; })
            .filter(Boolean);
        if (!dataToMerge.length) {
            throw new MissingLocaleDataError("Missing locale data for \"" + locale + "\", lookup hierarchy: " + localeHierarchy.join(', '));
        }
        dataToMerge.reverse();
        return dataToMerge.reduce(reducer, {});
    }

    // https://tc39.es/proposal-unified-intl-numberformat/section6/locales-currencies-tz_diff_out.html#sec-issanctionedsimpleunitidentifier
    var SANCTIONED_UNITS = [
        'angle-degree',
        'area-acre',
        'area-hectare',
        'concentr-percent',
        'digital-bit',
        'digital-byte',
        'digital-gigabit',
        'digital-gigabyte',
        'digital-kilobit',
        'digital-kilobyte',
        'digital-megabit',
        'digital-megabyte',
        'digital-petabyte',
        'digital-terabit',
        'digital-terabyte',
        'duration-day',
        'duration-hour',
        'duration-millisecond',
        'duration-minute',
        'duration-month',
        'duration-second',
        'duration-week',
        'duration-year',
        'length-centimeter',
        'length-foot',
        'length-inch',
        'length-kilometer',
        'length-meter',
        'length-mile-scandinavian',
        'length-mile',
        'length-millimeter',
        'length-yard',
        'mass-gram',
        'mass-kilogram',
        'mass-ounce',
        'mass-pound',
        'mass-stone',
        'temperature-celsius',
        'temperature-fahrenheit',
        'volume-fluid-ounce',
        'volume-gallon',
        'volume-liter',
        'volume-milliliter',
    ];

    var InternalSlotToken;
    (function (InternalSlotToken) {
        // To prevent collision with {0} in CLDR
        InternalSlotToken["compactName"] = "compactName";
        InternalSlotToken["compactSymbol"] = "compactSymbol";
        InternalSlotToken["currencyCode"] = "currencyCode";
        InternalSlotToken["currencyName"] = "currencyName";
        InternalSlotToken["currencyNarrowSymbol"] = "currencyNarrowSymbol";
        InternalSlotToken["currencySymbol"] = "currencySymbol";
        InternalSlotToken["minusSign"] = "minusSign";
        InternalSlotToken["number"] = "number";
        InternalSlotToken["percentSign"] = "percentSign";
        InternalSlotToken["plusSign"] = "plusSign";
        InternalSlotToken["scientificExponent"] = "scientificExponent";
        InternalSlotToken["scientificSeparator"] = "scientificSeparator";
        InternalSlotToken["unitName"] = "unitName";
        InternalSlotToken["unitNarrowSymbol"] = "unitNarrowSymbol";
        InternalSlotToken["unitSymbol"] = "unitSymbol";
    })(InternalSlotToken || (InternalSlotToken = {}));

    /**
     * Cannot do Math.log(x) / Math.log(10) bc if IEEE floating point issue
     * @param x number
     */
    function logBase10(x) {
        if (x < 1) {
            var fraction = String(x).split('.')[1];
            var exponent = 0;
            for (; fraction[exponent] === '0'; exponent++)
                ;
            return -exponent - 1;
        }
        return String(Math.floor(x)).length - 1;
    }
    // TODO: dedup with intl-pluralrules
    // https://tc39.es/proposal-unified-intl-numberformat/section11/numberformat_proposed_out.html#sec-torawfixed
    function toRawFixed(x, minFraction, maxFraction) {
        var f = maxFraction;
        var n;
        {
            var exactSolve = x * Math.pow(10, f);
            var roundDown = Math.floor(exactSolve);
            var roundUp = Math.ceil(exactSolve);
            n = exactSolve - roundDown < roundUp - exactSolve ? roundDown : roundUp;
        }
        var xFinal = n / Math.pow(10, f);
        var m = n === 0 ? '0' : n.toString();
        var int;
        if (f !== 0) {
            var k = m.length;
            if (k <= f) {
                var z = repeat('0', f + 1 - k);
                m = z + m;
                k = f + 1;
            }
            var a = m.slice(0, k - f);
            var b = m.slice(k - f);
            m = a + "." + b;
            int = a.length;
        }
        else {
            int = m.length;
        }
        var cut = maxFraction - minFraction;
        while (cut > 0 && m[m.length - 1] === '0') {
            m = m.slice(0, -1);
            cut--;
        }
        if (m[m.length - 1] === '.') {
            m = m.slice(0, -1);
        }
        return { formattedString: m, roundedNumber: xFinal, integerDigitsCount: int };
    }
    // https://tc39.es/proposal-unified-intl-numberformat/section11/numberformat_proposed_out.html#sec-torawprecision
    function toRawPrecision(x, minPrecision, maxPrecision) {
        var p = maxPrecision;
        var m;
        var e;
        var xFinal;
        if (x === 0) {
            m = repeat('0', p);
            e = 0;
            xFinal = 0;
        }
        else {
            e = Math.floor(logBase10(x));
            var n = void 0;
            {
                var exactSolve = x / Math.pow(10, (e - p + 1));
                var roundDown = Math.floor(exactSolve);
                var roundUp = Math.ceil(exactSolve);
                n = exactSolve - roundDown < roundUp - exactSolve ? roundDown : roundUp;
            }
            m = n.toString();
            xFinal = n * Math.pow(10, (e - p + 1));
        }
        var int;
        if (e >= p - 1) {
            m = m + repeat('0', e - p + 1);
            int = e + 1;
        }
        else if (e >= 0) {
            m = m.slice(0, e + 1) + "." + m.slice(e + 1);
            int = e + 1;
        }
        else {
            m = "0." + repeat('0', -e - 1) + m;
            int = 1;
        }
        if (m.indexOf('.') >= 0 && maxPrecision > minPrecision) {
            var cut = maxPrecision - minPrecision;
            while (cut > 0 && m[m.length - 1] === '0') {
                m = m.slice(0, -1);
                cut--;
            }
            if (m[m.length - 1] === '.') {
                m = m.slice(0, -1);
            }
        }
        return { formattedString: m, roundedNumber: xFinal, integerDigitsCount: int };
    }
    function repeat(s, times) {
        if (typeof s.repeat === 'function') {
            return s.repeat(times);
        }
        var arr = new Array(times);
        for (var i = 0; i < arr.length; i++) {
            arr[i] = s;
        }
        return arr.join('');
    }

    var CURRENCY_DISPLAYS = [
        'code',
        'symbol',
        'narrowSymbol',
        'name',
    ];
    var SIGN_DISPLAYS = [
        'auto',
        'always',
        'never',
        'exceptZero',
    ];
    // What is this number?
    // Context: https://github.com/tc39/proposal-unified-intl-numberformat/issues/26
    // Right now pattern tree does not have room for different compact notation pattern
    // per exponent (e.g for zh-TW, 1000 is just {number}, not {number}K).
    // This number is chosen so we generate the most general pattern for compact, e.g
    // {number}{compactSymbol} or sth like that
    var SPECIAL_NUMBER_HACK = '1000';
    var UNIT_DISPLAYS = ['narrow', 'long', 'short'];
    // g flag bc this appears twice in accounting pattern
    var CURRENCY_SYMBOL_REGEX = /¤/g;
    function extractDecimalFormatILD(data) {
        if (!data) {
            return;
        }
        return Object.keys(data).reduce(function (all, num) {
            var pattern = data[num];
            all[num] = Object.keys(pattern).reduce(function (all, p) {
                all[p] = (pattern[p] || '').replace(/[¤0]/g, '').trim();
                return all;
            }, { other: pattern.other.replace(/[¤0]/g, '').trim() });
            return all;
        }, {});
    }
    function extractLDMLPluralRuleMap(m, k) {
        return Object.keys(m).reduce(function (all, rule) {
            all[rule] = m[rule][k];
            return all;
        }, { other: m.other[k] });
    }
    function extractILD(units, currencies, numbers, numberingSystem) {
        return {
            decimal: {
                compactShort: extractDecimalFormatILD(numbers.decimal[numberingSystem].short),
                compactLong: extractDecimalFormatILD(numbers.decimal[numberingSystem].long),
            },
            currency: {
                compactShort: extractDecimalFormatILD(numbers.currency[numberingSystem].short),
            },
            symbols: numbers.symbols[numberingSystem],
            currencySymbols: Object.keys(currencies).reduce(function (all, code) {
                all[code] = {
                    currencyName: currencies[code].displayName,
                    currencySymbol: currencies[code].symbol,
                    currencyNarrowSymbol: currencies[code].narrow || currencies[code].symbol,
                };
                return all;
            }, {}),
            unitSymbols: Object.keys(units).reduce(function (all, unit) {
                all[unit] = {
                    unitSymbol: extractLDMLPluralRuleMap(units[unit].short, 'symbol'),
                    unitNarrowSymbol: extractLDMLPluralRuleMap(units[unit].narrow, 'symbol'),
                    unitName: extractLDMLPluralRuleMap(units[unit].long, 'symbol'),
                };
                return all;
            }, {}),
        };
    }
    // Credit: https://github.com/andyearnshaw/Intl.js/blob/master/scripts/utils/reduce.js
    // Matches CLDR number patterns, e.g. #,##0.00, #,##,##0.00, #,##0.##, 0, etc.
    var NUMBER_PATTERN = /[#0](?:[\.,][#0]+)*/g;
    var SCIENTIFIC_SLOT = [
        InternalSlotToken.number,
        InternalSlotToken.scientificSeparator,
        InternalSlotToken.scientificExponent,
    ]
        .map(function (t) { return "{" + t + "}"; })
        .join('');
    var DUMMY_PATTERN = '#';
    function produceSignPattern(positivePattern, negativePattern) {
        if (negativePattern === void 0) { negativePattern = ''; }
        if (!negativePattern) {
            negativePattern = "{" + InternalSlotToken.minusSign + "}" + positivePattern;
        }
        var zeroPattern = positivePattern;
        var alwaysPositivePattern = positivePattern.includes("{" + InternalSlotToken.plusSign + "}")
            ? positivePattern
            : "{" + InternalSlotToken.plusSign + "}" + positivePattern;
        return {
            always: {
                positivePattern: alwaysPositivePattern,
                zeroPattern: alwaysPositivePattern,
                negativePattern: negativePattern,
            },
            exceptZero: {
                positivePattern: alwaysPositivePattern,
                zeroPattern: zeroPattern,
                negativePattern: negativePattern,
            },
            never: {
                positivePattern: positivePattern,
                zeroPattern: zeroPattern,
                negativePattern: positivePattern,
            },
            auto: {
                positivePattern: positivePattern,
                zeroPattern: zeroPattern,
                negativePattern: negativePattern,
            },
        };
    }
    function extractSignPattern(pattern) {
        var patterns = pattern.split(';');
        var _a = patterns.map(function (p) {
            return p
                .replace(NUMBER_PATTERN, "{" + InternalSlotToken.number + "}")
                .replace('+', "{" + InternalSlotToken.plusSign + "}")
                .replace('-', "{" + InternalSlotToken.minusSign + "}")
                .replace('%', "{" + InternalSlotToken.percentSign + "}");
        }), positivePattern = _a[0], negativePattern = _a[1];
        return produceSignPattern(positivePattern, negativePattern);
    }
    var dummySignPattern = extractSignPattern(
    // Dummy
    DUMMY_PATTERN);
    var scientificSignPattern = extractSignPattern(SCIENTIFIC_SLOT);
    /**
     * Turn compact pattern like `0 trillion` or `¤0 trillion` to
     * `0 {compactSymbol}` or `¤0 {compactSymbol}`
     * @param pattern
     */
    function extractCompactSymbol(pattern, slotToken) {
        if (slotToken === void 0) { slotToken = InternalSlotToken.compactSymbol; }
        var compactUnit = pattern
            .replace(/[¤0]/g, '')
            // In case we're processing half-processed things
            .replace(/({\w+})/g, '')
            .trim();
        return pattern.replace(compactUnit, "{" + slotToken + "}");
    }
    function extractDecimalPattern(d, numberingSystem) {
        var compactShortSignPattern = extractSignPattern(extractCompactSymbol(d.decimal[numberingSystem].short[SPECIAL_NUMBER_HACK].other));
        var compactLongSignPattern = extractSignPattern(extractCompactSymbol(d.decimal[numberingSystem].long[SPECIAL_NUMBER_HACK].other, InternalSlotToken.compactName));
        return SIGN_DISPLAYS.reduce(function (all, k) {
            all[k] = {
                standard: dummySignPattern[k],
                scientific: scientificSignPattern[k],
                compactShort: compactShortSignPattern[k],
                compactLong: compactLongSignPattern[k],
            };
            return all;
        }, {});
    }
    function extractPercentPattern(d, numberingSystem) {
        var percentSignPattern = extractSignPattern(d.percent[numberingSystem]);
        var scientificPercentSignPattern = extractSignPattern(d.percent[numberingSystem].replace(NUMBER_PATTERN, SCIENTIFIC_SLOT));
        return SIGN_DISPLAYS.reduce(function (all, k) {
            all[k] = {
                standard: percentSignPattern[k],
                scientific: scientificPercentSignPattern[k],
                compactShort: percentSignPattern[k],
                compactLong: percentSignPattern[k],
            };
            return all;
        }, {});
    }
    var INSERT_BEFORE_PATTERN_REGEX = /[^\s(]¤/;
    var INSERT_AFTER_PATTERN_REGEX = /¤[^\s;]/;
    var S_UNICODE_REGEX = /\p{S}/u;
    function shouldInsertBefore(currency, pattern) {
        // surroundingMatch [:digit:] check
        return (INSERT_BEFORE_PATTERN_REGEX.test(pattern) &&
            // [:^S:]
            !S_UNICODE_REGEX.test(currency[0]));
    }
    function shouldInsertAfter(currency, pattern) {
        return (INSERT_AFTER_PATTERN_REGEX.test(pattern) &&
            // [:^S:]
            !S_UNICODE_REGEX.test(currency[currency.length - 1]));
    }
    /**
     *
     * @param currencyUnitPattern
     * @param decimalShortPattern
     * @param decimalLongPattern
     * @param currencyToken
     */
    function extractStandardCurrencyPattern(currencyStandardPattern, currencyUnitPattern, currencyShortPattern, decimalShortPattern, decimalLongPattern, currencyDisplay) {
        var standardPattern;
        var scientificPattern;
        var compactShortPattern;
        var compactLongPattern;
        // For full currency name, we use unitPattern in conjunction with
        // decimal short/long pattern, so
        // `{0} {1}` + `0 thousand` -> `0 thousand {1}` -> {number} {compactName} {currencyName}`
        if (currencyDisplay === 'name') {
            standardPattern = currencyUnitPattern.replace(STANDARD_PATTERN_REGEX, function (_, p) {
                return p === '0' ? DUMMY_PATTERN : "{" + InternalSlotToken.currencyName + "}";
            });
            scientificPattern = currencyUnitPattern.replace(STANDARD_PATTERN_REGEX, function (_, p) {
                return p === '0' ? SCIENTIFIC_SLOT : "{" + InternalSlotToken.currencyName + "}";
            });
            compactShortPattern = currencyUnitPattern.replace(STANDARD_PATTERN_REGEX, function (_, p) {
                return p === '0'
                    ? extractCompactSymbol(decimalShortPattern)
                    : "{" + InternalSlotToken.currencyName + "}";
            });
            compactLongPattern = currencyUnitPattern.replace(STANDARD_PATTERN_REGEX, function (_, p) {
                return p === '0'
                    ? extractCompactSymbol(decimalLongPattern, InternalSlotToken.compactName)
                    : "{" + InternalSlotToken.currencyName + "}";
            });
        }
        // For currency symbol/code, it's trickier
        // standard uses the currency standard pattern
        // scientific uses the currency standard pattern but replace digits w/ scientific pattern
        // short uses currency short pattern, otherwise nothing
        // long uses currency long pattern, otherwise short, otherwise nothing
        else {
            standardPattern = currencyStandardPattern;
            scientificPattern = currencyStandardPattern.replace(NUMBER_PATTERN, SCIENTIFIC_SLOT);
            compactShortPattern = extractCompactSymbol(currencyShortPattern);
            compactLongPattern = extractCompactSymbol(currencyShortPattern);
        }
        return SIGN_DISPLAYS.reduce(function (all, signDisplay) {
            all[signDisplay] = {
                standard: extractSignPattern(standardPattern)[signDisplay],
                scientific: extractSignPattern(scientificPattern)[signDisplay],
                compactShort: extractSignPattern(compactShortPattern)[signDisplay],
                compactLong: extractSignPattern(compactLongPattern)[signDisplay],
            };
            return all;
        }, {});
    }
    function extractAccountingCurrencyPattern(currencyAccountingPattern, currencyUnitPattern, currencyShortPattern, decimalShortPattern, decimalLongPattern, currencyDisplay) {
        var standardPattern;
        var scientificPattern;
        var compactShortPattern;
        var compactLongPattern;
        // For full currency name, we use unitPattern in conjunction with
        // decimal short/long pattern, so
        // `{0} {1}` + `0 thousand` -> `0 thousand {1}` -> {number} {compactName} {currencyName}`
        if (currencyDisplay === 'name') {
            standardPattern = currencyUnitPattern.replace(STANDARD_PATTERN_REGEX, function (_, p) {
                return p === '0' ? DUMMY_PATTERN : "{" + InternalSlotToken.currencyName + "}";
            });
            scientificPattern = currencyUnitPattern.replace(STANDARD_PATTERN_REGEX, function (_, p) {
                return p === '0' ? SCIENTIFIC_SLOT : "{" + InternalSlotToken.currencyName + "}";
            });
            compactShortPattern = currencyUnitPattern.replace(STANDARD_PATTERN_REGEX, function (_, p) {
                return p === '0'
                    ? extractCompactSymbol(decimalShortPattern)
                    : "{" + InternalSlotToken.currencyName + "}";
            });
            compactLongPattern = currencyUnitPattern.replace(STANDARD_PATTERN_REGEX, function (_, p) {
                return p === '0'
                    ? extractCompactSymbol(decimalLongPattern, InternalSlotToken.compactName)
                    : "{" + InternalSlotToken.currencyName + "}";
            });
        }
        // For currency symbol/code, it's trickier
        // standard uses the currency accounting pattern
        // scientific uses the currency accounting pattern but replace digits w/ scientific pattern
        // short uses currency short pattern, otherwise nothing
        // long uses currency long pattern, otherwise short, otherwise nothing
        else {
            standardPattern = currencyAccountingPattern;
            scientificPattern = currencyAccountingPattern.replace(NUMBER_PATTERN, SCIENTIFIC_SLOT);
            compactShortPattern = extractCompactSymbol(currencyShortPattern);
            compactLongPattern = extractCompactSymbol(currencyShortPattern);
        }
        return SIGN_DISPLAYS.reduce(function (all, signDisplay) {
            all[signDisplay] = {
                standard: extractSignPattern(standardPattern)[signDisplay],
                scientific: extractSignPattern(scientificPattern)[signDisplay],
                compactShort: extractSignPattern(compactShortPattern)[signDisplay],
                compactLong: extractSignPattern(compactLongPattern)[signDisplay],
            };
            return all;
        }, {});
    }
    function replaceCurrencySymbolWithToken(currency, pattern, insertBetween, currencyToken) {
        // Check afterCurrency
        if (shouldInsertAfter(currency, pattern)) {
            return pattern.replace(CURRENCY_SYMBOL_REGEX, "{" + currencyToken + "}" + insertBetween);
        }
        // Check beforeCurrency
        if (shouldInsertBefore(currency, pattern)) {
            return pattern.replace(CURRENCY_SYMBOL_REGEX, insertBetween + "{" + currencyToken + "}");
        }
        return pattern.replace(CURRENCY_SYMBOL_REGEX, "{" + currencyToken + "}");
    }
    function extractCurrencyPatternForCurrency(d, c, currency, numberingSystem) {
        var _a;
        var insertBetween = d.currency[numberingSystem].currencySpacing.beforeInsertBetween;
        var currencyStandardPattern = d.currency[numberingSystem].standard;
        var currencyUnitPattern = d.currency[numberingSystem].unitPattern;
        var currencyAccountingPattern = d.currency[numberingSystem].accounting;
        var currencyShortPattern = ((_a = d.currency[numberingSystem].short) === null || _a === void 0 ? void 0 : _a[1000].other) || '';
        var decimalShortPattern = d.decimal[numberingSystem].short[SPECIAL_NUMBER_HACK].other;
        var decimalLongPattern = d.decimal[numberingSystem].long[SPECIAL_NUMBER_HACK].other;
        var currencySymbol = c[currency].symbol;
        var currencyNarrowSymbol = c[currency].narrow;
        var standardCurrencyPattern = {
            standard: extractStandardCurrencyPattern(currencyStandardPattern, currencyUnitPattern, currencyShortPattern, decimalShortPattern, decimalLongPattern, 'name'),
            accounting: extractAccountingCurrencyPattern(currencyAccountingPattern, currencyUnitPattern, currencyShortPattern, decimalShortPattern, decimalLongPattern, 'name'),
        };
        return CURRENCY_DISPLAYS.reduce(function (all, currencyDisplay) {
            if (currencyDisplay === 'name') {
                all[currencyDisplay] = standardCurrencyPattern;
            }
            else {
                var currencyToken = currencyDisplay === 'code'
                    ? InternalSlotToken.currencyCode
                    : currencyDisplay === 'symbol'
                        ? InternalSlotToken.currencySymbol
                        : InternalSlotToken.currencyNarrowSymbol;
                var resolvedCurrency = currencyDisplay === 'code'
                    ? currency
                    : currencyDisplay === 'symbol'
                        ? currencySymbol
                        : currencyNarrowSymbol;
                all[currencyDisplay] = {
                    standard: extractStandardCurrencyPattern(replaceCurrencySymbolWithToken(resolvedCurrency, currencyStandardPattern, insertBetween, currencyToken), currencyUnitPattern, replaceCurrencySymbolWithToken(resolvedCurrency, currencyShortPattern, insertBetween, currencyToken), decimalShortPattern, decimalLongPattern, currencyDisplay),
                    accounting: extractAccountingCurrencyPattern(replaceCurrencySymbolWithToken(resolvedCurrency, currencyAccountingPattern, insertBetween, currencyToken), currencyUnitPattern, replaceCurrencySymbolWithToken(resolvedCurrency, currencyShortPattern, insertBetween, currencyToken), decimalShortPattern, decimalLongPattern, currencyDisplay),
                };
            }
            return all;
        }, {});
    }
    var STANDARD_PATTERN_REGEX = /{(\d)}/g;
    function generateUnitPatternPayload(unitPatternStr, display, compactShortDecimalPattern, compactLongDecimalPattern) {
        var unitToken = display === 'long'
            ? InternalSlotToken.unitName
            : display === 'short'
                ? InternalSlotToken.unitSymbol
                : InternalSlotToken.unitNarrowSymbol;
        var standardUnitPatternStr = unitPatternStr.replace(STANDARD_PATTERN_REGEX, function (_, p) { return (p === '0' ? DUMMY_PATTERN : "{" + unitToken + "}"); });
        var scientificUnitPatternStr = unitPatternStr.replace(STANDARD_PATTERN_REGEX, function (_, p) { return (p === '0' ? SCIENTIFIC_SLOT : "{" + unitToken + "}"); });
        var compactShortUnitPatternStr = unitPatternStr.replace(STANDARD_PATTERN_REGEX, function (_, p) {
            return p === '0'
                ? extractCompactSymbol(compactShortDecimalPattern)
                : "{" + unitToken + "}";
        });
        var compactLongUnitPatternStr = unitPatternStr.replace(STANDARD_PATTERN_REGEX, function (_, p) {
            return p === '0'
                ? extractCompactSymbol(compactLongDecimalPattern, InternalSlotToken.compactName)
                : "{" + unitToken + "}";
        });
        var standard = extractSignPattern(standardUnitPatternStr);
        var scientific = extractSignPattern(scientificUnitPatternStr);
        var compactShort = extractSignPattern(compactShortUnitPatternStr);
        var compactLong = extractSignPattern(compactLongUnitPatternStr);
        return SIGN_DISPLAYS.reduce(function (all, k) {
            all[k] = {
                standard: standard[k],
                scientific: scientific[k],
                compactShort: compactShort[k],
                compactLong: compactLong[k],
            };
            return all;
        }, {});
    }
    function extractUnitPatternForUnit(d, u, unit, numberingSystem) {
        var unitData = u[unit];
        var patterns = {};
        for (var _i = 0, UNIT_DISPLAYS_1 = UNIT_DISPLAYS; _i < UNIT_DISPLAYS_1.length; _i++) {
            var unitDisplay = UNIT_DISPLAYS_1[_i];
            patterns[unitDisplay] = generateUnitPatternPayload(unitData[unitDisplay].other.pattern, unitDisplay, d.decimal[numberingSystem].short[SPECIAL_NUMBER_HACK].other, d.decimal[numberingSystem].long[SPECIAL_NUMBER_HACK].other);
        }
        return patterns;
    }
    function generateContinuousILND(startChar) {
        var startCharCode = startChar.charCodeAt(0);
        var arr = new Array(10);
        for (var i = 0; i < 10; i++) {
            arr[i] = String.fromCharCode(startCharCode + i);
        }
        return arr;
    }
    // https://tc39.es/proposal-unified-intl-numberformat/section11/numberformat_proposed_out.html#table-numbering-system-digits
    var ILND = (function () {
        return {
            arab: generateContinuousILND('\u0660'),
            arabext: generateContinuousILND('\u06f0'),
            bali: generateContinuousILND('\u1b50'),
            beng: generateContinuousILND('\u09e6'),
            deva: generateContinuousILND('\u0966'),
            fullwide: generateContinuousILND('\uff10'),
            gujr: generateContinuousILND('\u0ae6'),
            guru: generateContinuousILND('\u0a66'),
            khmr: generateContinuousILND('\u17e0'),
            knda: generateContinuousILND('\u0ce6'),
            laoo: generateContinuousILND('\u0ed0'),
            latn: generateContinuousILND('\u0030'),
            limb: generateContinuousILND('\u1946'),
            mlym: generateContinuousILND('\u0d66'),
            mong: generateContinuousILND('\u1810'),
            mymr: generateContinuousILND('\u1040'),
            orya: generateContinuousILND('\u0b66'),
            tamldec: generateContinuousILND('\u0be6'),
            telu: generateContinuousILND('\u0c66'),
            thai: generateContinuousILND('\u0e50'),
            tibt: generateContinuousILND('\u0f20'),
            hanidec: [
                '\u3007',
                '\u4e00',
                '\u4e8c',
                '\u4e09',
                '\u56db',
                '\u4e94',
                '\u516d',
                '\u4e03',
                '\u516b',
                '\u4e5d',
            ],
        };
    })();
    function extractPatterns(units, currencies, numbers, numberingSystem, unit, currency) {
        var _a, _b;
        return {
            decimal: extractDecimalPattern(numbers, numberingSystem),
            percent: extractPercentPattern(numbers, numberingSystem),
            unit: unit
                ? (_a = {},
                    _a[unit] = extractUnitPatternForUnit(numbers, units, unit, numberingSystem),
                    _a) : {},
            currency: currency
                ? (_b = {},
                    _b[currency] = extractCurrencyPatternForCurrency(numbers, currencies, currency, numberingSystem),
                    _b) : {},
        };
    }

    var ADP = 0;
    var AFN = 0;
    var ALL = 0;
    var AMD = 2;
    var BHD = 3;
    var BIF = 0;
    var BYN = 2;
    var BYR = 0;
    var CAD = 2;
    var CHF = 2;
    var CLF = 4;
    var CLP = 0;
    var COP = 2;
    var CRC = 2;
    var CZK = 2;
    var DEFAULT = 2;
    var DJF = 0;
    var DKK = 2;
    var ESP = 0;
    var GNF = 0;
    var GYD = 2;
    var HUF = 2;
    var IDR = 2;
    var IQD = 0;
    var IRR = 0;
    var ISK = 0;
    var ITL = 0;
    var JOD = 3;
    var JPY = 0;
    var KMF = 0;
    var KPW = 0;
    var KRW = 0;
    var KWD = 3;
    var LAK = 0;
    var LBP = 0;
    var LUF = 0;
    var LYD = 3;
    var MGA = 0;
    var MGF = 0;
    var MMK = 0;
    var MNT = 2;
    var MRO = 0;
    var MUR = 2;
    var NOK = 2;
    var OMR = 3;
    var PKR = 2;
    var PYG = 0;
    var RSD = 0;
    var RWF = 0;
    var SEK = 2;
    var SLL = 0;
    var SOS = 0;
    var STD = 0;
    var SYP = 0;
    var TMM = 0;
    var TND = 3;
    var TRL = 0;
    var TWD = 2;
    var TZS = 2;
    var UGX = 0;
    var UYI = 0;
    var UYW = 4;
    var UZS = 2;
    var VEF = 2;
    var VND = 0;
    var VUV = 0;
    var XAF = 0;
    var XOF = 0;
    var XPF = 0;
    var YER = 0;
    var ZMK = 0;
    var ZWD = 0;
    var currencyDigits = {
    	ADP: ADP,
    	AFN: AFN,
    	ALL: ALL,
    	AMD: AMD,
    	BHD: BHD,
    	BIF: BIF,
    	BYN: BYN,
    	BYR: BYR,
    	CAD: CAD,
    	CHF: CHF,
    	CLF: CLF,
    	CLP: CLP,
    	COP: COP,
    	CRC: CRC,
    	CZK: CZK,
    	DEFAULT: DEFAULT,
    	DJF: DJF,
    	DKK: DKK,
    	ESP: ESP,
    	GNF: GNF,
    	GYD: GYD,
    	HUF: HUF,
    	IDR: IDR,
    	IQD: IQD,
    	IRR: IRR,
    	ISK: ISK,
    	ITL: ITL,
    	JOD: JOD,
    	JPY: JPY,
    	KMF: KMF,
    	KPW: KPW,
    	KRW: KRW,
    	KWD: KWD,
    	LAK: LAK,
    	LBP: LBP,
    	LUF: LUF,
    	LYD: LYD,
    	MGA: MGA,
    	MGF: MGF,
    	MMK: MMK,
    	MNT: MNT,
    	MRO: MRO,
    	MUR: MUR,
    	NOK: NOK,
    	OMR: OMR,
    	PKR: PKR,
    	PYG: PYG,
    	RSD: RSD,
    	RWF: RWF,
    	SEK: SEK,
    	SLL: SLL,
    	SOS: SOS,
    	STD: STD,
    	SYP: SYP,
    	TMM: TMM,
    	TND: TND,
    	TRL: TRL,
    	TWD: TWD,
    	TZS: TZS,
    	UGX: UGX,
    	UYI: UYI,
    	UYW: UYW,
    	UZS: UZS,
    	VEF: VEF,
    	VND: VND,
    	VUV: VUV,
    	XAF: XAF,
    	XOF: XOF,
    	XPF: XPF,
    	YER: YER,
    	ZMK: ZMK,
    	ZWD: ZWD
    };

    var currencyDigitsData = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ADP: ADP,
        AFN: AFN,
        ALL: ALL,
        AMD: AMD,
        BHD: BHD,
        BIF: BIF,
        BYN: BYN,
        BYR: BYR,
        CAD: CAD,
        CHF: CHF,
        CLF: CLF,
        CLP: CLP,
        COP: COP,
        CRC: CRC,
        CZK: CZK,
        DEFAULT: DEFAULT,
        DJF: DJF,
        DKK: DKK,
        ESP: ESP,
        GNF: GNF,
        GYD: GYD,
        HUF: HUF,
        IDR: IDR,
        IQD: IQD,
        IRR: IRR,
        ISK: ISK,
        ITL: ITL,
        JOD: JOD,
        JPY: JPY,
        KMF: KMF,
        KPW: KPW,
        KRW: KRW,
        KWD: KWD,
        LAK: LAK,
        LBP: LBP,
        LUF: LUF,
        LYD: LYD,
        MGA: MGA,
        MGF: MGF,
        MMK: MMK,
        MNT: MNT,
        MRO: MRO,
        MUR: MUR,
        NOK: NOK,
        OMR: OMR,
        PKR: PKR,
        PYG: PYG,
        RSD: RSD,
        RWF: RWF,
        SEK: SEK,
        SLL: SLL,
        SOS: SOS,
        STD: STD,
        SYP: SYP,
        TMM: TMM,
        TND: TND,
        TRL: TRL,
        TWD: TWD,
        TZS: TZS,
        UGX: UGX,
        UYI: UYI,
        UYW: UYW,
        UZS: UZS,
        VEF: VEF,
        VND: VND,
        VUV: VUV,
        XAF: XAF,
        XOF: XOF,
        XPF: XPF,
        YER: YER,
        ZMK: ZMK,
        ZWD: ZWD,
        'default': currencyDigits
    });

    var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };
    var RESOLVED_OPTIONS_KEYS = [
        'locale',
        'numberingSystem',
        'style',
        'currency',
        'currencyDisplay',
        'currencySign',
        'unit',
        'unitDisplay',
        'minimumIntegerDigits',
        'minimumFractionDigits',
        'maximumFractionDigits',
        'minimumSignificantDigits',
        'maximumSignificantDigits',
        'useGrouping',
        'notation',
        'compactDisplay',
        'signDisplay',
    ];
    var SHORTENED_SACTION_UNITS = SANCTIONED_UNITS.map(function (unit) {
        return unit.replace(/^(.*?)-/, '');
    });
    var NOT_A_Z_REGEX = /[^A-Z]/;
    function toUpperCase(str) {
        return str.replace(/([a-z])/g, function (_, c) { return c.toUpperCase(); });
    }
    function toLowerCase(str) {
        return str.replace(/([A-Z])/g, function (_, c) { return c.toLowerCase(); });
    }
    /**
     * https://tc39.es/proposal-unified-intl-numberformat/section6/locales-currencies-tz_proposed_out.html#sec-iswellformedcurrencycode
     * @param currency
     */
    function isWellFormedCurrencyCode(currency) {
        currency = toUpperCase(currency);
        if (currency.length !== 3) {
            return false;
        }
        if (NOT_A_Z_REGEX.test(currency)) {
            return false;
        }
        return true;
    }
    /**
     * https://tc39.es/proposal-unified-intl-numberformat/section6/locales-currencies-tz_proposed_out.html#sec-iswellformedunitidentifier
     * @param unit
     */
    function isWellFormedUnitIdentifier(unit) {
        unit = toLowerCase(unit);
        if (SHORTENED_SACTION_UNITS.indexOf(unit) > -1) {
            return true;
        }
        var units = unit.split('-per-');
        if (units.length !== 2) {
            return false;
        }
        if (SHORTENED_SACTION_UNITS.indexOf(units[0]) < 0 ||
            SHORTENED_SACTION_UNITS.indexOf(units[1]) < 0) {
            return false;
        }
        return true;
    }
    /**
     * Check if a formatting number with unit is supported
     * @public
     * @param unit unit to check
     */
    function isUnitSupported(unit) {
        try {
            new Intl.NumberFormat(undefined, {
                style: 'unit',
                unit: unit,
            });
        }
        catch (e) {
            return false;
        }
        return true;
    }
    var __INTERNAL_SLOT_MAP__ = new WeakMap();
    function currencyDigits$1(c) {
        return c in currencyDigitsData ? currencyDigitsData[c] : 2;
    }
    function initializeNumberFormat(nf, locales, opts) {
        var requestedLocales = getCanonicalLocales(locales);
        var options = opts === undefined ? Object.create(null) : toObject(opts);
        var opt = Object.create(null);
        var matcher = getOption(options, 'localeMatcher', 'string', ['best fit', 'lookup'], 'best fit');
        opt.localeMatcher = matcher;
        var localeData = UnifiedNumberFormat.localeData;
        var r = createResolveLocale(UnifiedNumberFormat.getDefaultLocale)(getInternalSlot(__INTERNAL_SLOT_MAP__, nf, 'availableLocales'), requestedLocales, opt, getInternalSlot(__INTERNAL_SLOT_MAP__, nf, 'relevantExtensionKeys'), localeData);
        var ildData = localeData[r.locale];
        var numberingSystem = r.nu;
        setMultiInternalSlots(__INTERNAL_SLOT_MAP__, nf, {
            locale: r.locale,
            dataLocale: r.dataLocale,
            numberingSystem: numberingSystem,
            ild: extractILD(ildData.units, ildData.currencies, ildData.numbers, numberingSystem),
        });
        // https://tc39.es/proposal-unified-intl-numberformat/section11/numberformat_proposed_out.html#sec-setnumberformatunitoptions
        setNumberFormatUnitOptions(nf, options);
        var style = getInternalSlot(__INTERNAL_SLOT_MAP__, nf, 'style');
        // ---
        var mnfdDefault;
        var mxfdDefault;
        if (style === 'currency') {
            var currency = getInternalSlot(__INTERNAL_SLOT_MAP__, nf, 'currency');
            var cDigits = currencyDigits$1(currency);
            mnfdDefault = cDigits;
            mxfdDefault = cDigits;
        }
        else {
            mnfdDefault = 0;
            mxfdDefault = style === 'percent' ? 0 : 3;
        }
        var notation = getOption(options, 'notation', 'string', ['standard', 'scientific', 'engineering', 'compact'], 'standard');
        setInternalSlot(__INTERNAL_SLOT_MAP__, nf, 'notation', notation);
        setNumberFormatDigitOptions(__INTERNAL_SLOT_MAP__, nf, options, mnfdDefault, mxfdDefault, notation);
        var compactDisplay = getOption(options, 'compactDisplay', 'string', ['short', 'long'], 'short');
        if (notation === 'compact') {
            setInternalSlot(__INTERNAL_SLOT_MAP__, nf, 'compactDisplay', compactDisplay);
        }
        var useGrouping = getOption(options, 'useGrouping', 'boolean', undefined, true);
        setInternalSlot(__INTERNAL_SLOT_MAP__, nf, 'useGrouping', useGrouping);
        var signDisplay = getOption(options, 'signDisplay', 'string', ['auto', 'never', 'always', 'exceptZero'], 'auto');
        setInternalSlot(__INTERNAL_SLOT_MAP__, nf, 'signDisplay', signDisplay);
    }
    var UnifiedNumberFormat = /** @class */ (function () {
        // private unitPattern?: UnitData;
        // private currencyNarrowSymbol?: string;
        function UnifiedNumberFormat(locales, options) {
            // Cannot use `new.target` bc of IE11 & TS transpiles it to something else
            var newTarget = this && this instanceof UnifiedNumberFormat ? this.constructor : void 0;
            if (!newTarget) {
                throw new TypeError("Intl.PluralRules must be called with 'new'");
            }
            setMultiInternalSlots(__INTERNAL_SLOT_MAP__, this, {
                relevantExtensionKeys: ['nu'],
                availableLocales: UnifiedNumberFormat.availableLocales,
            });
            initializeNumberFormat(this, locales, options);
            var _a = getInternalSlot(__INTERNAL_SLOT_MAP__, this, 'locale'), ildData = UnifiedNumberFormat.localeData[_a];
            this.pl = new Intl.PluralRules(locales);
            setMultiInternalSlots(__INTERNAL_SLOT_MAP__, this, {
                patterns: extractPatterns(ildData.units, ildData.currencies, ildData.numbers, getInternalSlot(__INTERNAL_SLOT_MAP__, this, 'numberingSystem'), getInternalSlot(__INTERNAL_SLOT_MAP__, this, 'unit'), getInternalSlot(__INTERNAL_SLOT_MAP__, this, 'currency')),
            });
            // test262/test/intl402/NumberFormat/prototype/format/bound-to-numberformat-instance.js
            this.format = this.format.bind(this);
            this.formatToParts = this.formatToParts.bind(this);
        }
        UnifiedNumberFormat.prototype.format = function (num) {
            return this.formatToParts(num)
                .map(function (x) { return x.value; })
                .join('');
        };
        UnifiedNumberFormat.prototype.formatToParts = function (x) {
            // https://tc39.es/proposal-unified-intl-numberformat/section11/numberformat_proposed_out.html#sec-partitionnumberpattern
            var exponent = 0;
            var ild = getInternalSlot(__INTERNAL_SLOT_MAP__, this, 'ild');
            var n;
            x = toNumeric(x);
            var formattedX = x;
            if (isNaN(x)) {
                n = ild.symbols.nan;
            }
            else if (!isFinite(x)) {
                n = ild.symbols.infinity;
            }
            else {
                if (getInternalSlot(__INTERNAL_SLOT_MAP__, this, 'style') === 'percent') {
                    formattedX *= 100;
                }
                exponent = computeExponent(this, formattedX);
                formattedX /= Math.pow(10, exponent);
                var formatNumberResult = formatNumberToString(this, formattedX);
                n = formatNumberResult.formattedString;
                formattedX = formatNumberResult.roundedNumber;
            }
            var pattern = getNumberFormatPattern(this, x, exponent);
            var patternParts = pattern.split(/({\w+})/).filter(Boolean);
            var results = [];
            for (var _i = 0, patternParts_1 = patternParts; _i < patternParts_1.length; _i++) {
                var part = patternParts_1[_i];
                if (part[0] !== '{') {
                    results.push({ type: 'literal', value: part });
                }
                else {
                    var p = part.slice(1, -1);
                    switch (p) {
                        case InternalSlotToken.number: {
                            if (isNaN(formattedX)) {
                                results.push({ type: 'nan', value: n });
                            }
                            else if (formattedX === Infinity || x === -Infinity) {
                                results.push({ type: 'infinity', value: n });
                            }
                            else {
                                var _a = getMultiInternalSlots(__INTERNAL_SLOT_MAP__, this, 'numberingSystem', 'useGrouping'), nu = _a.numberingSystem, useGrouping = _a.useGrouping;
                                if (nu && ILND.hasOwnProperty(nu)) {
                                    // Replace digits
                                    var replacementTable = ILND[nu];
                                    var replacedDigits = '';
                                    for (var _b = 0, n_1 = n; _b < n_1.length; _b++) {
                                        var digit = n_1[_b];
                                        // digit can be `.` if it's fractional
                                        replacedDigits += replacementTable[+digit] || digit;
                                    }
                                    n = replacedDigits;
                                }
                                var decimalSepIndex = n.indexOf('.');
                                var integer = void 0;
                                var fraction = void 0;
                                if (decimalSepIndex > 0) {
                                    integer = n.slice(0, decimalSepIndex);
                                    fraction = n.slice(decimalSepIndex + 1);
                                }
                                else {
                                    integer = n;
                                }
                                if (useGrouping) {
                                    var groupSepSymbol = ild.symbols.group;
                                    var groups = [];
                                    // Assuming that the group separator is always inserted between every 3 digits.
                                    var i = integer.length - 3;
                                    for (; i > 0; i -= 3) {
                                        groups.push(integer.slice(i, i + 3));
                                    }
                                    groups.push(integer.slice(0, i + 3));
                                    while (groups.length > 0) {
                                        var integerGroup = groups.pop();
                                        results.push({ type: 'integer', value: integerGroup });
                                        if (groups.length > 0) {
                                            results.push({ type: 'group', value: groupSepSymbol });
                                        }
                                    }
                                }
                                else {
                                    results.push({ type: 'integer', value: integer });
                                }
                                if (fraction !== undefined) {
                                    results.push({ type: 'decimal', value: ild.symbols.decimal }, { type: 'fraction', value: fraction });
                                }
                            }
                            break;
                        }
                        case InternalSlotToken.plusSign:
                            results.push({
                                type: 'plusSign',
                                value: ild.symbols.plusSign,
                            });
                            break;
                        case InternalSlotToken.minusSign:
                            results.push({
                                type: 'minusSign',
                                value: ild.symbols.minusSign,
                            });
                            break;
                        case InternalSlotToken.compactSymbol:
                        case InternalSlotToken.compactName:
                            var compactData = ild.decimal[p === 'compactName' ? 'compactLong' : 'compactShort'];
                            if (compactData) {
                                results.push({
                                    type: 'compact',
                                    value: selectPlural(this.pl, formattedX, compactData[String(Math.pow(10, exponent))]),
                                });
                            }
                            break;
                        case InternalSlotToken.scientificSeparator:
                            results.push({
                                type: 'exponentSeparator',
                                value: ild.symbols.exponential,
                            });
                            break;
                        case InternalSlotToken.scientificExponent: {
                            if (exponent < 0) {
                                results.push({
                                    type: 'exponentMinusSign',
                                    value: ild.symbols.minusSign,
                                });
                                exponent = -exponent;
                            }
                            var exponentResult = toRawFixed(exponent, 0, 0);
                            results.push({
                                type: 'exponentInteger',
                                value: exponentResult.formattedString,
                            });
                            break;
                        }
                        case InternalSlotToken.percentSign:
                            results.push({
                                type: 'percentSign',
                                value: ild.symbols.percentSign,
                            });
                            break;
                        case InternalSlotToken.unitSymbol:
                        case InternalSlotToken.unitNarrowSymbol:
                        case InternalSlotToken.unitName: {
                            var style = getInternalSlot(__INTERNAL_SLOT_MAP__, this, 'style');
                            if (style === 'unit') {
                                var unit = getInternalSlot(__INTERNAL_SLOT_MAP__, this, 'unit');
                                var unitSymbols = ild.unitSymbols[unit];
                                var mu = selectPlural(this.pl, formattedX, unitSymbols[p] || unitSymbols[InternalSlotToken.unitSymbol]);
                                results.push({ type: 'unit', value: mu });
                            }
                            break;
                        }
                        case InternalSlotToken.currencyCode:
                        case InternalSlotToken.currencySymbol:
                        case InternalSlotToken.currencyNarrowSymbol:
                        case InternalSlotToken.currencyName: {
                            var currency = getInternalSlot(__INTERNAL_SLOT_MAP__, this, 'currency');
                            var cd = void 0;
                            if (p === InternalSlotToken.currencyCode) {
                                cd = currency;
                            }
                            else if (p === InternalSlotToken.currencyName) {
                                // TODO: make plural work with scientific notation
                                cd = selectPlural(this.pl, formattedX, ild.currencySymbols[currency].currencyName);
                            }
                            else {
                                cd = ild.currencySymbols[currency][p];
                            }
                            results.push({ type: 'currency', value: cd });
                            break;
                        }
                        default:
                            throw Error("unrecognized pattern part \"" + p + "\" in \"" + pattern + "\"");
                    }
                }
            }
            return results;
        };
        UnifiedNumberFormat.prototype.resolvedOptions = function () {
            var slots = getMultiInternalSlots.apply(void 0, __spreadArrays([__INTERNAL_SLOT_MAP__,
                this], RESOLVED_OPTIONS_KEYS));
            var ro = {};
            for (var _i = 0, RESOLVED_OPTIONS_KEYS_1 = RESOLVED_OPTIONS_KEYS; _i < RESOLVED_OPTIONS_KEYS_1.length; _i++) {
                var key = RESOLVED_OPTIONS_KEYS_1[_i];
                var value = slots[key];
                if (value !== undefined) {
                    ro[key] = value;
                }
            }
            return ro;
        };
        UnifiedNumberFormat.supportedLocalesOf = function (locales, options) {
            return supportedLocales(UnifiedNumberFormat.availableLocales, getCanonicalLocales(locales), options);
        };
        UnifiedNumberFormat.__addLocaleData = function () {
            var data = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                data[_i] = arguments[_i];
            }
            for (var _a = 0, data_1 = data; _a < data_1.length; _a++) {
                var datum = data_1[_a];
                var availableLocales = Object.keys(__spreadArrays(datum.availableLocales, Object.keys(datum.aliases), Object.keys(datum.parentLocales)).reduce(function (all, k) {
                    all[k] = true;
                    return all;
                }, {}));
                for (var _b = 0, availableLocales_1 = availableLocales; _b < availableLocales_1.length; _b++) {
                    var locale = availableLocales_1[_b];
                    try {
                        UnifiedNumberFormat.localeData[locale] = unpackData(locale, datum);
                    }
                    catch (e) {
                        // Ignore if we got no data
                    }
                }
            }
            UnifiedNumberFormat.availableLocales = Object.keys(UnifiedNumberFormat.localeData);
            if (!UnifiedNumberFormat.__defaultLocale) {
                UnifiedNumberFormat.__defaultLocale =
                    UnifiedNumberFormat.availableLocales[0];
            }
        };
        UnifiedNumberFormat.getDefaultLocale = function () {
            return UnifiedNumberFormat.__defaultLocale;
        };
        UnifiedNumberFormat.localeData = {};
        UnifiedNumberFormat.availableLocales = [];
        UnifiedNumberFormat.__defaultLocale = 'en';
        UnifiedNumberFormat.polyfilled = true;
        return UnifiedNumberFormat;
    }());
    function setNumberFormatUnitOptions(nf, options) {
        if (options === void 0) { options = {}; }
        // https://tc39.es/proposal-unified-intl-numberformat/section11/numberformat_proposed_out.html#sec-setnumberformatunitoptions
        var style = getOption(options, 'style', 'string', ['decimal', 'percent', 'currency', 'unit'], 'decimal');
        setInternalSlot(__INTERNAL_SLOT_MAP__, nf, 'style', style);
        var currency = getOption(options, 'currency', 'string', undefined, undefined);
        if (currency !== undefined && !isWellFormedCurrencyCode(currency)) {
            throw RangeError('Malformed currency code');
        }
        var currencyDisplay = getOption(options, 'currencyDisplay', 'string', ['code', 'symbol', 'narrowSymbol', 'name'], 'symbol');
        var currencySign = getOption(options, 'currencySign', 'string', ['standard', 'accounting'], 'standard');
        var unit = getOption(options, 'unit', 'string', undefined, undefined);
        if (unit !== undefined && !isWellFormedUnitIdentifier(unit)) {
            throw RangeError('Invalid unit argument for Intl.NumberFormat()');
        }
        var unitDisplay = getOption(options, 'unitDisplay', 'string', ['short', 'narrow', 'long'], 'short');
        if (style === 'currency') {
            if (currency === undefined) {
                throw new TypeError('currency cannot be undefined');
            }
            setMultiInternalSlots(__INTERNAL_SLOT_MAP__, nf, {
                currency: currency.toUpperCase(),
                currencyDisplay: currencyDisplay,
                currencySign: currencySign,
            });
        }
        else if (style === 'unit') {
            if (unit === undefined) {
                throw new TypeError('unit cannot be undefined');
            }
            setMultiInternalSlots(__INTERNAL_SLOT_MAP__, nf, {
                unit: unit,
                unitDisplay: unitDisplay,
            });
        }
    }
    // Taking the shortcut here and used the native NumberFormat for formatting numbers.
    function formatNumberToString(numberFormat, x) {
        var isNegative = x < 0 || objectIs(x, -0);
        if (isNegative) {
            x = -x;
        }
        var _a = getMultiInternalSlots(__INTERNAL_SLOT_MAP__, numberFormat, 'roundingType', 'minimumFractionDigits', 'maximumFractionDigits', 'minimumIntegerDigits', 'minimumSignificantDigits', 'maximumSignificantDigits'), roundingType = _a.roundingType, minimumSignificantDigits = _a.minimumSignificantDigits, maximumSignificantDigits = _a.maximumSignificantDigits, minimumFractionDigits = _a.minimumFractionDigits, maximumFractionDigits = _a.maximumFractionDigits, minimumIntegerDigits = _a.minimumIntegerDigits;
        var result;
        if (roundingType === 'significantDigits') {
            result = toRawPrecision(x, minimumSignificantDigits, maximumSignificantDigits);
        }
        else if (roundingType === 'fractionDigits') {
            result = toRawFixed(x, minimumFractionDigits, maximumFractionDigits);
        }
        else {
            invariant(roundingType === 'compactRounding', 'roundingType must be compactRounding');
            result = toRawFixed(x, 0, 0);
            if (result.integerDigitsCount === 1) {
                result = toRawPrecision(x, 1, 2);
            }
        }
        x = result.roundedNumber;
        var string = result.formattedString;
        var int = result.integerDigitsCount;
        var minInteger = minimumIntegerDigits;
        if (int < minInteger) {
            var forwardZeros = repeat('0', minInteger - int);
            string = forwardZeros + string;
        }
        if (isNegative) {
            x = -x;
        }
        return { roundedNumber: x, formattedString: string };
    }
    /**
     * The abstract operation ComputeExponent computes an exponent (power of ten) by which to scale x
     * according to the number formatting settings. It handles cases such as 999 rounding up to 1000,
     * requiring a different exponent.
     */
    function computeExponent(numberFormat, x) {
        if (x === 0) {
            return 0;
        }
        if (x < 0) {
            x = -x;
        }
        var magnitude = logBase10(x);
        var exponent = computeExponentForMagnitude(numberFormat, magnitude);
        x = x / Math.pow(10, exponent); // potential IEEE floating point error
        var formatNumberResult = formatNumberToString(numberFormat, x);
        if (formatNumberResult.roundedNumber === 0) {
            return exponent;
        }
        var newMagnitude = logBase10(x);
        if (newMagnitude === magnitude - exponent) {
            return exponent;
        }
        return computeExponentForMagnitude(numberFormat, magnitude + 1);
    }
    /**
     * The abstract operation ComputeExponentForMagnitude computes an exponent by which to scale a
     * number of the given magnitude (power of ten of the most significant digit) according to the
     * locale and the desired notation (scientific, engineering, or compact).
     */
    function computeExponentForMagnitude(numberFormat, magnitude) {
        var notation = getInternalSlot(__INTERNAL_SLOT_MAP__, numberFormat, 'notation');
        var style = getInternalSlot(__INTERNAL_SLOT_MAP__, numberFormat, 'style');
        var ild = getInternalSlot(__INTERNAL_SLOT_MAP__, numberFormat, 'ild');
        switch (notation) {
            case 'standard':
                return 0;
            case 'scientific':
                return magnitude;
            case 'engineering':
                return Math.floor(magnitude / 3) * 3;
            case 'compact': {
                var symbols = style === 'decimal' ? ild.decimal : ild.currency;
                var thresholdMap = symbols.compactLong || symbols.compactShort;
                if (!thresholdMap) {
                    return 0;
                }
                var num = String(Math.pow(10, magnitude));
                var thresholds = Object.keys(thresholdMap); // TODO: this can be pre-processed
                if (num < thresholds[0]) {
                    return 0;
                }
                if (num > thresholds[thresholds.length - 1]) {
                    return logBase10(+thresholds[thresholds.length - 1]);
                }
                var i = thresholds.indexOf(num);
                for (; i > 0 &&
                    thresholdMap[thresholds[i - 1]].other === thresholdMap[num].other; i--)
                    ;
                return logBase10(+thresholds[i]);
            }
        }
    }
    /**
     * https://tc39.es/proposal-unified-intl-numberformat/section11/numberformat_proposed_out.html#sec-getnumberformatpattern
     *
     * The abstract operation GetNumberFormatPattern considers the resolved unit-related options in the
     * number format object along with the final scaled and rounded number being formatted and returns a
     * pattern, a String value as described in 1.3.3.
     */
    function getNumberFormatPattern(numberFormat, x, exponent) {
        var _a = getMultiInternalSlots(__INTERNAL_SLOT_MAP__, numberFormat, 'style', 'patterns', 'signDisplay', 'notation'), style = _a.style, slots = _a.patterns;
        var patterns;
        switch (style) {
            case 'percent':
                patterns = slots.percent;
                break;
            case 'unit': {
                var unitDisplay = getInternalSlot(__INTERNAL_SLOT_MAP__, numberFormat, 'unitDisplay');
                var unit = getInternalSlot(__INTERNAL_SLOT_MAP__, numberFormat, 'unit');
                patterns = slots.unit[unit][unitDisplay];
                break;
            }
            case 'currency': {
                var _b = getMultiInternalSlots(__INTERNAL_SLOT_MAP__, numberFormat, 'currency', 'currencyDisplay', 'currencySign'), currency = _b.currency, currencyDisplay = _b.currencyDisplay, currencySign = _b.currencySign;
                patterns = slots.currency[currency][currencyDisplay][currencySign];
                break;
            }
            case 'decimal':
                patterns = slots.decimal;
                break;
        }
        var notation = getInternalSlot(__INTERNAL_SLOT_MAP__, numberFormat, 'notation');
        var displayNotation = 'standard';
        if (!isNaN(x) && isFinite(x)) {
            if (notation === 'scientific' || notation === 'engineering') {
                displayNotation = 'scientific';
            }
            else if (exponent !== 0) {
                invariant(notation === 'compact', 'notation must be compact');
                var compactDisplay = getInternalSlot(__INTERNAL_SLOT_MAP__, numberFormat, 'compactDisplay');
                if (compactDisplay === 'short') {
                    displayNotation = 'compactShort';
                }
                else {
                    invariant(compactDisplay === 'long', 'compactDisplay must be long');
                    displayNotation = 'compactLong';
                }
            }
        }
        var signDisplay = getInternalSlot(__INTERNAL_SLOT_MAP__, numberFormat, 'signDisplay');
        var signPattern = patterns[signDisplay][displayNotation];
        var pattern;
        if (signDisplay === 'never') {
            pattern = signPattern.zeroPattern;
        }
        else if (signDisplay === 'auto') {
            if (objectIs(x, 0) || x > 0 || isNaN(x)) {
                pattern = signPattern.zeroPattern;
            }
            else {
                pattern = signPattern.negativePattern;
            }
        }
        else if (signDisplay === 'always') {
            if (objectIs(x, 0) || x > 0 || isNaN(x)) {
                pattern = signPattern.positivePattern;
            }
            else {
                pattern = signPattern.negativePattern;
            }
        }
        else {
            invariant(signDisplay === 'exceptZero', 'signDisplay must be exceptZero');
            if (objectIs(x, 0) || isNaN(x)) {
                pattern = signPattern.zeroPattern;
            }
            else if (x > 0 || objectIs(x, +0)) {
                pattern = signPattern.positivePattern;
            }
            else {
                pattern = signPattern.negativePattern;
            }
        }
        return pattern;
    }
    function selectPlural(pl, x, rules) {
        return rules[pl.select(x)] || rules.other;
    }
    function toNumeric(val) {
        if (typeof val === 'bigint') {
            return val;
        }
        return toNumber(val);
    }
    function toNumber(val) {
        if (val === undefined) {
            return NaN;
        }
        if (val === null) {
            return +0;
        }
        if (typeof val === 'boolean') {
            return val ? 1 : +0;
        }
        if (typeof val === 'number') {
            return val;
        }
        if (typeof val === 'symbol' || typeof val === 'bigint') {
            throw new TypeError('Cannot convert symbol/bigint to number');
        }
        return Number(val);
    }
    try {
        // IE11 does not have Symbol
        if (typeof Symbol !== 'undefined') {
            Object.defineProperty(UnifiedNumberFormat.prototype, Symbol.toStringTag, {
                value: 'Object',
                writable: false,
                enumerable: false,
                configurable: true,
            });
        }
        // test262/test/intl402/NumberFormat/name.js
        Object.defineProperty(UnifiedNumberFormat, 'name', {
            value: 'NumberFormat',
            writable: false,
            enumerable: false,
            configurable: true,
        });
        // https://github.com/tc39/test262/blob/master/test/intl402/NumberFormat/constructor/length.js
        Object.defineProperty(UnifiedNumberFormat.prototype.constructor, 'length', {
            value: 0,
            writable: false,
            enumerable: false,
            configurable: true,
        });
        // https://github.com/tc39/test262/blob/master/test/intl402/NumberFormat/constructor/supportedLocalesOf/length.js
        Object.defineProperty(UnifiedNumberFormat.supportedLocalesOf, 'length', {
            value: 1,
            writable: false,
            enumerable: false,
            configurable: true,
        });
    }
    catch (e) {
        // Meta fix so we're test262-compliant, not important
    }

    if (!isUnitSupported('bit')) {
        Intl.NumberFormat = UnifiedNumberFormat;
    }

})));
//# sourceMappingURL=polyfill.js.map
