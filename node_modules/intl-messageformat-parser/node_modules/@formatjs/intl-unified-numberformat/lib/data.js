import { InternalSlotToken, } from '@formatjs/intl-utils';
var CURRENCY_DISPLAYS = [
    'code',
    'symbol',
    'narrowSymbol',
    'name',
];
var SIGN_DISPLAYS = [
    'auto',
    'always',
    'never',
    'exceptZero',
];
// What is this number?
// Context: https://github.com/tc39/proposal-unified-intl-numberformat/issues/26
// Right now pattern tree does not have room for different compact notation pattern
// per exponent (e.g for zh-TW, 1000 is just {number}, not {number}K).
// This number is chosen so we generate the most general pattern for compact, e.g
// {number}{compactSymbol} or sth like that
var SPECIAL_NUMBER_HACK = '1000';
var UNIT_DISPLAYS = ['narrow', 'long', 'short'];
// g flag bc this appears twice in accounting pattern
var CURRENCY_SYMBOL_REGEX = /¤/g;
function extractDecimalFormatILD(data) {
    if (!data) {
        return;
    }
    return Object.keys(data).reduce(function (all, num) {
        var pattern = data[num];
        all[num] = Object.keys(pattern).reduce(function (all, p) {
            all[p] = (pattern[p] || '').replace(/[¤0]/g, '').trim();
            return all;
        }, { other: pattern.other.replace(/[¤0]/g, '').trim() });
        return all;
    }, {});
}
function extractLDMLPluralRuleMap(m, k) {
    return Object.keys(m).reduce(function (all, rule) {
        all[rule] = m[rule][k];
        return all;
    }, { other: m.other[k] });
}
export function extractILD(units, currencies, numbers, numberingSystem) {
    return {
        decimal: {
            compactShort: extractDecimalFormatILD(numbers.decimal[numberingSystem].short),
            compactLong: extractDecimalFormatILD(numbers.decimal[numberingSystem].long),
        },
        currency: {
            compactShort: extractDecimalFormatILD(numbers.currency[numberingSystem].short),
        },
        symbols: numbers.symbols[numberingSystem],
        currencySymbols: Object.keys(currencies).reduce(function (all, code) {
            all[code] = {
                currencyName: currencies[code].displayName,
                currencySymbol: currencies[code].symbol,
                currencyNarrowSymbol: currencies[code].narrow || currencies[code].symbol,
            };
            return all;
        }, {}),
        unitSymbols: Object.keys(units).reduce(function (all, unit) {
            all[unit] = {
                unitSymbol: extractLDMLPluralRuleMap(units[unit].short, 'symbol'),
                unitNarrowSymbol: extractLDMLPluralRuleMap(units[unit].narrow, 'symbol'),
                unitName: extractLDMLPluralRuleMap(units[unit].long, 'symbol'),
            };
            return all;
        }, {}),
    };
}
// Credit: https://github.com/andyearnshaw/Intl.js/blob/master/scripts/utils/reduce.js
// Matches CLDR number patterns, e.g. #,##0.00, #,##,##0.00, #,##0.##, 0, etc.
var NUMBER_PATTERN = /[#0](?:[\.,][#0]+)*/g;
var SCIENTIFIC_SLOT = [
    InternalSlotToken.number,
    InternalSlotToken.scientificSeparator,
    InternalSlotToken.scientificExponent,
]
    .map(function (t) { return "{" + t + "}"; })
    .join('');
var DUMMY_PATTERN = '#';
function produceSignPattern(positivePattern, negativePattern) {
    if (negativePattern === void 0) { negativePattern = ''; }
    if (!negativePattern) {
        negativePattern = "{" + InternalSlotToken.minusSign + "}" + positivePattern;
    }
    var zeroPattern = positivePattern;
    var alwaysPositivePattern = positivePattern.includes("{" + InternalSlotToken.plusSign + "}")
        ? positivePattern
        : "{" + InternalSlotToken.plusSign + "}" + positivePattern;
    return {
        always: {
            positivePattern: alwaysPositivePattern,
            zeroPattern: alwaysPositivePattern,
            negativePattern: negativePattern,
        },
        exceptZero: {
            positivePattern: alwaysPositivePattern,
            zeroPattern: zeroPattern,
            negativePattern: negativePattern,
        },
        never: {
            positivePattern: positivePattern,
            zeroPattern: zeroPattern,
            negativePattern: positivePattern,
        },
        auto: {
            positivePattern: positivePattern,
            zeroPattern: zeroPattern,
            negativePattern: negativePattern,
        },
    };
}
function extractSignPattern(pattern) {
    var patterns = pattern.split(';');
    var _a = patterns.map(function (p) {
        return p
            .replace(NUMBER_PATTERN, "{" + InternalSlotToken.number + "}")
            .replace('+', "{" + InternalSlotToken.plusSign + "}")
            .replace('-', "{" + InternalSlotToken.minusSign + "}")
            .replace('%', "{" + InternalSlotToken.percentSign + "}");
    }), positivePattern = _a[0], negativePattern = _a[1];
    return produceSignPattern(positivePattern, negativePattern);
}
var dummySignPattern = extractSignPattern(
// Dummy
DUMMY_PATTERN);
var scientificSignPattern = extractSignPattern(SCIENTIFIC_SLOT);
/**
 * Turn compact pattern like `0 trillion` or `¤0 trillion` to
 * `0 {compactSymbol}` or `¤0 {compactSymbol}`
 * @param pattern
 */
function extractCompactSymbol(pattern, slotToken) {
    if (slotToken === void 0) { slotToken = InternalSlotToken.compactSymbol; }
    var compactUnit = pattern
        .replace(/[¤0]/g, '')
        // In case we're processing half-processed things
        .replace(/({\w+})/g, '')
        .trim();
    return pattern.replace(compactUnit, "{" + slotToken + "}");
}
function extractDecimalPattern(d, numberingSystem) {
    var compactShortSignPattern = extractSignPattern(extractCompactSymbol(d.decimal[numberingSystem].short[SPECIAL_NUMBER_HACK].other));
    var compactLongSignPattern = extractSignPattern(extractCompactSymbol(d.decimal[numberingSystem].long[SPECIAL_NUMBER_HACK].other, InternalSlotToken.compactName));
    return SIGN_DISPLAYS.reduce(function (all, k) {
        all[k] = {
            standard: dummySignPattern[k],
            scientific: scientificSignPattern[k],
            compactShort: compactShortSignPattern[k],
            compactLong: compactLongSignPattern[k],
        };
        return all;
    }, {});
}
function extractPercentPattern(d, numberingSystem) {
    var percentSignPattern = extractSignPattern(d.percent[numberingSystem]);
    var scientificPercentSignPattern = extractSignPattern(d.percent[numberingSystem].replace(NUMBER_PATTERN, SCIENTIFIC_SLOT));
    return SIGN_DISPLAYS.reduce(function (all, k) {
        all[k] = {
            standard: percentSignPattern[k],
            scientific: scientificPercentSignPattern[k],
            compactShort: percentSignPattern[k],
            compactLong: percentSignPattern[k],
        };
        return all;
    }, {});
}
var INSERT_BEFORE_PATTERN_REGEX = /[^\s(]¤/;
var INSERT_AFTER_PATTERN_REGEX = /¤[^\s;]/;
var S_UNICODE_REGEX = /\p{S}/u;
function shouldInsertBefore(currency, pattern) {
    // surroundingMatch [:digit:] check
    return (INSERT_BEFORE_PATTERN_REGEX.test(pattern) &&
        // [:^S:]
        !S_UNICODE_REGEX.test(currency[0]));
}
function shouldInsertAfter(currency, pattern) {
    return (INSERT_AFTER_PATTERN_REGEX.test(pattern) &&
        // [:^S:]
        !S_UNICODE_REGEX.test(currency[currency.length - 1]));
}
/**
 *
 * @param currencyUnitPattern
 * @param decimalShortPattern
 * @param decimalLongPattern
 * @param currencyToken
 */
function extractStandardCurrencyPattern(currencyStandardPattern, currencyUnitPattern, currencyShortPattern, decimalShortPattern, decimalLongPattern, currencyDisplay) {
    var standardPattern;
    var scientificPattern;
    var compactShortPattern;
    var compactLongPattern;
    // For full currency name, we use unitPattern in conjunction with
    // decimal short/long pattern, so
    // `{0} {1}` + `0 thousand` -> `0 thousand {1}` -> {number} {compactName} {currencyName}`
    if (currencyDisplay === 'name') {
        standardPattern = currencyUnitPattern.replace(STANDARD_PATTERN_REGEX, function (_, p) {
            return p === '0' ? DUMMY_PATTERN : "{" + InternalSlotToken.currencyName + "}";
        });
        scientificPattern = currencyUnitPattern.replace(STANDARD_PATTERN_REGEX, function (_, p) {
            return p === '0' ? SCIENTIFIC_SLOT : "{" + InternalSlotToken.currencyName + "}";
        });
        compactShortPattern = currencyUnitPattern.replace(STANDARD_PATTERN_REGEX, function (_, p) {
            return p === '0'
                ? extractCompactSymbol(decimalShortPattern)
                : "{" + InternalSlotToken.currencyName + "}";
        });
        compactLongPattern = currencyUnitPattern.replace(STANDARD_PATTERN_REGEX, function (_, p) {
            return p === '0'
                ? extractCompactSymbol(decimalLongPattern, InternalSlotToken.compactName)
                : "{" + InternalSlotToken.currencyName + "}";
        });
    }
    // For currency symbol/code, it's trickier
    // standard uses the currency standard pattern
    // scientific uses the currency standard pattern but replace digits w/ scientific pattern
    // short uses currency short pattern, otherwise nothing
    // long uses currency long pattern, otherwise short, otherwise nothing
    else {
        standardPattern = currencyStandardPattern;
        scientificPattern = currencyStandardPattern.replace(NUMBER_PATTERN, SCIENTIFIC_SLOT);
        compactShortPattern = extractCompactSymbol(currencyShortPattern);
        compactLongPattern = extractCompactSymbol(currencyShortPattern);
    }
    return SIGN_DISPLAYS.reduce(function (all, signDisplay) {
        all[signDisplay] = {
            standard: extractSignPattern(standardPattern)[signDisplay],
            scientific: extractSignPattern(scientificPattern)[signDisplay],
            compactShort: extractSignPattern(compactShortPattern)[signDisplay],
            compactLong: extractSignPattern(compactLongPattern)[signDisplay],
        };
        return all;
    }, {});
}
function extractAccountingCurrencyPattern(currencyAccountingPattern, currencyUnitPattern, currencyShortPattern, decimalShortPattern, decimalLongPattern, currencyDisplay) {
    var standardPattern;
    var scientificPattern;
    var compactShortPattern;
    var compactLongPattern;
    // For full currency name, we use unitPattern in conjunction with
    // decimal short/long pattern, so
    // `{0} {1}` + `0 thousand` -> `0 thousand {1}` -> {number} {compactName} {currencyName}`
    if (currencyDisplay === 'name') {
        standardPattern = currencyUnitPattern.replace(STANDARD_PATTERN_REGEX, function (_, p) {
            return p === '0' ? DUMMY_PATTERN : "{" + InternalSlotToken.currencyName + "}";
        });
        scientificPattern = currencyUnitPattern.replace(STANDARD_PATTERN_REGEX, function (_, p) {
            return p === '0' ? SCIENTIFIC_SLOT : "{" + InternalSlotToken.currencyName + "}";
        });
        compactShortPattern = currencyUnitPattern.replace(STANDARD_PATTERN_REGEX, function (_, p) {
            return p === '0'
                ? extractCompactSymbol(decimalShortPattern)
                : "{" + InternalSlotToken.currencyName + "}";
        });
        compactLongPattern = currencyUnitPattern.replace(STANDARD_PATTERN_REGEX, function (_, p) {
            return p === '0'
                ? extractCompactSymbol(decimalLongPattern, InternalSlotToken.compactName)
                : "{" + InternalSlotToken.currencyName + "}";
        });
    }
    // For currency symbol/code, it's trickier
    // standard uses the currency accounting pattern
    // scientific uses the currency accounting pattern but replace digits w/ scientific pattern
    // short uses currency short pattern, otherwise nothing
    // long uses currency long pattern, otherwise short, otherwise nothing
    else {
        standardPattern = currencyAccountingPattern;
        scientificPattern = currencyAccountingPattern.replace(NUMBER_PATTERN, SCIENTIFIC_SLOT);
        compactShortPattern = extractCompactSymbol(currencyShortPattern);
        compactLongPattern = extractCompactSymbol(currencyShortPattern);
    }
    return SIGN_DISPLAYS.reduce(function (all, signDisplay) {
        all[signDisplay] = {
            standard: extractSignPattern(standardPattern)[signDisplay],
            scientific: extractSignPattern(scientificPattern)[signDisplay],
            compactShort: extractSignPattern(compactShortPattern)[signDisplay],
            compactLong: extractSignPattern(compactLongPattern)[signDisplay],
        };
        return all;
    }, {});
}
function replaceCurrencySymbolWithToken(currency, pattern, insertBetween, currencyToken) {
    // Check afterCurrency
    if (shouldInsertAfter(currency, pattern)) {
        return pattern.replace(CURRENCY_SYMBOL_REGEX, "{" + currencyToken + "}" + insertBetween);
    }
    // Check beforeCurrency
    if (shouldInsertBefore(currency, pattern)) {
        return pattern.replace(CURRENCY_SYMBOL_REGEX, insertBetween + "{" + currencyToken + "}");
    }
    return pattern.replace(CURRENCY_SYMBOL_REGEX, "{" + currencyToken + "}");
}
function extractCurrencyPatternForCurrency(d, c, currency, numberingSystem) {
    var _a;
    var insertBetween = d.currency[numberingSystem].currencySpacing.beforeInsertBetween;
    var currencyStandardPattern = d.currency[numberingSystem].standard;
    var currencyUnitPattern = d.currency[numberingSystem].unitPattern;
    var currencyAccountingPattern = d.currency[numberingSystem].accounting;
    var currencyShortPattern = ((_a = d.currency[numberingSystem].short) === null || _a === void 0 ? void 0 : _a[1000].other) || '';
    var decimalShortPattern = d.decimal[numberingSystem].short[SPECIAL_NUMBER_HACK].other;
    var decimalLongPattern = d.decimal[numberingSystem].long[SPECIAL_NUMBER_HACK].other;
    var currencySymbol = c[currency].symbol;
    var currencyNarrowSymbol = c[currency].narrow;
    var standardCurrencyPattern = {
        standard: extractStandardCurrencyPattern(currencyStandardPattern, currencyUnitPattern, currencyShortPattern, decimalShortPattern, decimalLongPattern, 'name'),
        accounting: extractAccountingCurrencyPattern(currencyAccountingPattern, currencyUnitPattern, currencyShortPattern, decimalShortPattern, decimalLongPattern, 'name'),
    };
    return CURRENCY_DISPLAYS.reduce(function (all, currencyDisplay) {
        if (currencyDisplay === 'name') {
            all[currencyDisplay] = standardCurrencyPattern;
        }
        else {
            var currencyToken = currencyDisplay === 'code'
                ? InternalSlotToken.currencyCode
                : currencyDisplay === 'symbol'
                    ? InternalSlotToken.currencySymbol
                    : InternalSlotToken.currencyNarrowSymbol;
            var resolvedCurrency = currencyDisplay === 'code'
                ? currency
                : currencyDisplay === 'symbol'
                    ? currencySymbol
                    : currencyNarrowSymbol;
            all[currencyDisplay] = {
                standard: extractStandardCurrencyPattern(replaceCurrencySymbolWithToken(resolvedCurrency, currencyStandardPattern, insertBetween, currencyToken), currencyUnitPattern, replaceCurrencySymbolWithToken(resolvedCurrency, currencyShortPattern, insertBetween, currencyToken), decimalShortPattern, decimalLongPattern, currencyDisplay),
                accounting: extractAccountingCurrencyPattern(replaceCurrencySymbolWithToken(resolvedCurrency, currencyAccountingPattern, insertBetween, currencyToken), currencyUnitPattern, replaceCurrencySymbolWithToken(resolvedCurrency, currencyShortPattern, insertBetween, currencyToken), decimalShortPattern, decimalLongPattern, currencyDisplay),
            };
        }
        return all;
    }, {});
}
var STANDARD_PATTERN_REGEX = /{(\d)}/g;
function generateUnitPatternPayload(unitPatternStr, display, compactShortDecimalPattern, compactLongDecimalPattern) {
    var unitToken = display === 'long'
        ? InternalSlotToken.unitName
        : display === 'short'
            ? InternalSlotToken.unitSymbol
            : InternalSlotToken.unitNarrowSymbol;
    var standardUnitPatternStr = unitPatternStr.replace(STANDARD_PATTERN_REGEX, function (_, p) { return (p === '0' ? DUMMY_PATTERN : "{" + unitToken + "}"); });
    var scientificUnitPatternStr = unitPatternStr.replace(STANDARD_PATTERN_REGEX, function (_, p) { return (p === '0' ? SCIENTIFIC_SLOT : "{" + unitToken + "}"); });
    var compactShortUnitPatternStr = unitPatternStr.replace(STANDARD_PATTERN_REGEX, function (_, p) {
        return p === '0'
            ? extractCompactSymbol(compactShortDecimalPattern)
            : "{" + unitToken + "}";
    });
    var compactLongUnitPatternStr = unitPatternStr.replace(STANDARD_PATTERN_REGEX, function (_, p) {
        return p === '0'
            ? extractCompactSymbol(compactLongDecimalPattern, InternalSlotToken.compactName)
            : "{" + unitToken + "}";
    });
    var standard = extractSignPattern(standardUnitPatternStr);
    var scientific = extractSignPattern(scientificUnitPatternStr);
    var compactShort = extractSignPattern(compactShortUnitPatternStr);
    var compactLong = extractSignPattern(compactLongUnitPatternStr);
    return SIGN_DISPLAYS.reduce(function (all, k) {
        all[k] = {
            standard: standard[k],
            scientific: scientific[k],
            compactShort: compactShort[k],
            compactLong: compactLong[k],
        };
        return all;
    }, {});
}
function extractUnitPatternForUnit(d, u, unit, numberingSystem) {
    var unitData = u[unit];
    var patterns = {};
    for (var _i = 0, UNIT_DISPLAYS_1 = UNIT_DISPLAYS; _i < UNIT_DISPLAYS_1.length; _i++) {
        var unitDisplay = UNIT_DISPLAYS_1[_i];
        patterns[unitDisplay] = generateUnitPatternPayload(unitData[unitDisplay].other.pattern, unitDisplay, d.decimal[numberingSystem].short[SPECIAL_NUMBER_HACK].other, d.decimal[numberingSystem].long[SPECIAL_NUMBER_HACK].other);
    }
    return patterns;
}
function generateContinuousILND(startChar) {
    var startCharCode = startChar.charCodeAt(0);
    var arr = new Array(10);
    for (var i = 0; i < 10; i++) {
        arr[i] = String.fromCharCode(startCharCode + i);
    }
    return arr;
}
// https://tc39.es/proposal-unified-intl-numberformat/section11/numberformat_proposed_out.html#table-numbering-system-digits
export var ILND = (function () {
    return {
        arab: generateContinuousILND('\u0660'),
        arabext: generateContinuousILND('\u06f0'),
        bali: generateContinuousILND('\u1b50'),
        beng: generateContinuousILND('\u09e6'),
        deva: generateContinuousILND('\u0966'),
        fullwide: generateContinuousILND('\uff10'),
        gujr: generateContinuousILND('\u0ae6'),
        guru: generateContinuousILND('\u0a66'),
        khmr: generateContinuousILND('\u17e0'),
        knda: generateContinuousILND('\u0ce6'),
        laoo: generateContinuousILND('\u0ed0'),
        latn: generateContinuousILND('\u0030'),
        limb: generateContinuousILND('\u1946'),
        mlym: generateContinuousILND('\u0d66'),
        mong: generateContinuousILND('\u1810'),
        mymr: generateContinuousILND('\u1040'),
        orya: generateContinuousILND('\u0b66'),
        tamldec: generateContinuousILND('\u0be6'),
        telu: generateContinuousILND('\u0c66'),
        thai: generateContinuousILND('\u0e50'),
        tibt: generateContinuousILND('\u0f20'),
        hanidec: [
            '\u3007',
            '\u4e00',
            '\u4e8c',
            '\u4e09',
            '\u56db',
            '\u4e94',
            '\u516d',
            '\u4e03',
            '\u516b',
            '\u4e5d',
        ],
    };
})();
export function extractPatterns(units, currencies, numbers, numberingSystem, unit, currency) {
    var _a, _b;
    return {
        decimal: extractDecimalPattern(numbers, numberingSystem),
        percent: extractPercentPattern(numbers, numberingSystem),
        unit: unit
            ? (_a = {},
                _a[unit] = extractUnitPatternForUnit(numbers, units, unit, numberingSystem),
                _a) : {},
        currency: currency
            ? (_b = {},
                _b[currency] = extractCurrencyPatternForCurrency(numbers, currencies, currency, numberingSystem),
                _b) : {},
    };
}
